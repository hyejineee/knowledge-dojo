### 1. POST의 용도 3가지를 설명하시오. (141~145p)
- 어떤 리소스의 서브 리소스 작성 : 새로운 리소스를 생성하고 새롭게 생성한 리소스의 uri를 location 헤더의 필드 값으로 넣어준 응답을 보낸다. 
```markdown
요청 
POST /list HTTP/1.1
Host : ~
Content-Type : ~

안녕하세요. // post body에는 새롭게 생성할 리소스의 내용이 들어간다.

응답 
HTTP/1.1 201 Created
Content-Type : ~
Location : http: example.com/list/item5)

안녕하세요.
```


- 리소스에 데이터 추가 : 
  - 기존의 리소스에 데이터를 추가한다.
  - 201 created가 아니라 200 ok를 반환한다. 

- 다른 메서드로 대응할 수 없는 처리 : 이론적으로 uri의 길이에는 제한이 없지만 구현상 제한이 있기 떄문에 긴 키워드를 uri에 포함 시킬 수 없는 문제 발생 -> POST를 사용하여 키워드를 요청 메세지에 넣어 보낸다. 

### 2. 리소스 작성시 POST와 PUT 중에 POST를 쓰는게 적절한 이유는 무엇인가? (149p)
- PUT의 기능 
1. 리소스 갱신 
2. 리소스 생성 : put으로 존재하지 않는 uri에 대해 요청시 서버는 새로운 리소스를 새로 작성한다고 해석. 클라가 요청한 uri를 식별자로 하는 새로운 리소스 생성.  

- post와 put의 리소스 생성 차이  
: post의 경우 새롭게 작성한 리소스의 uri가 location 헤더로 반환.
put의 경우 클라이언트가 이미 리소스의 uri를 알고 있기 때문에 location을 반환할 필요 없음.

- post와 put의 구분   
: post로 리소스를 생성할 경우 uri 결정권은 서버 측이 갖고 있지만 put으로 리소스를 생성할 경우 uri의 결정권은 클라이언트 측이 갖게된다. 클라이언트 측에서 uri를 결정하기 위해서는 서버의 내부 구현을 알아야 하기 때문에 서버와 클라이언트 밀접해 진다.
때문에 post로 리소스 작성을 수행하여 uri를 서버측에서 결정하는 설계가 바람직 하다. 

### 3. HEAD의 사용 용도는 무엇인가? (151p)
- HEAD : 리소스의 헤더 정보만 취득하는 메소드.  
head의 응답에는 바디가 폼함되지 않기 떄문에 네트워크 대역을 절약하면서 리소스의 정보에 대해 조사할 수 있다. 

### 4. 다음 요청과 응답의 의미는 각각 무엇인가? (152p)

```markdown
요청
OPTIONS /list/item1 HTTP/1.1
Host: Example.com

응답
HTTP/1.1 200 OK
Allow: GET, HEAD, PUT, DELETE
```

### 5. 멱등성, 안전에 대해서 각각 설명하시오. (157p)
- 멱등성 : 어떤 조작을 몇 번을 반복해도 결과가 동일한 것을 의미 
- 안전 : 조작 대상이 되는 리소스의 상태를 변화 시키지 않는 것.
  - 부작용 : 리소스의 상태에 변화를 부여하는 것.

### 6. 멱등성과 안전을 기준으로 GET, HEAD, PUT, DELETE, POST를 분류하시오. (158p)

### 7. GET을 바르게 이용하고 있는지 판단하는 기준은 무엇인가? (164p)
- get의 실행 전후에 리소스에 변경이 가해졌는지 여부 

### 8. 현재 토마토 가격은 100원이다. PUT으로 토마토 가격을 갱신할 때 다음 PUT 사용은 어떤 부분이 잘못됐는가? 또한 올바른 표현은 무엇인가? (165~167p)

```markdown
PUT /tomato HTTP/1.1
Host: example.com
Content-Type: text/plain; charset=utf-8

+50
```

### 9. 스테이터스 코드 1xx, 2xx, 3xx, 4xx, 5xx의 분류와 의미를 설명하시오. (173~174p)

### 10. 스테이터스 코드에서 첫 번째 숫자를 이용한 분류 방식의 장점을 모두 설명하시오. (174~175p)

1. 스테이터스 코드를 분류함으로써, 클라이언트는 숫자를 보고 서버가 어떤 응답을 보낸 것인지 이해할 수 있고 클라이언트에서 어떻게 응답을 처리해야 할지 대략 알 수 있다. 

2. 클라이언트와 서버간의 약속을 최소화하여 클라이언트와 서버의 결합을 완화한다. 
3. 완화된 결합으로 각 컴포넌트 간의 독립성이 생기고 확장이 용이하게 된다.
### 11. 다음 응답 코드의 문제점은 무엇인가? (189p)

```markdown
HTTP/1.1 200 OK
Content-Type: application/xml

<error>
  <code>1001</code>
  <message>file not found</message>
</error>
```

### 12. HTTP에서 기술되는 일시는 어떤 표준시를 따르는가? (196p)

### 13. UTF-8로 선언된 xml 문서의 경우 `Content-Type` 헤더에 들어갈 알맞은 값은 무엇인가? (200~201p)

### 14. Content Negotiation이란 무엇인가? (202p)
- 클라이언트와 서버가 제공하는 리소스의 내용에 대해 교섭하는 것.
- 클라이언트에게 최적의 콘텐츠를 돌려준다. 
- 판단 기준으로 아래의 헤더가 사용된다.
  - Accept
  - Accept-Charset
  - Accept-Encoding
  - Accept-Language  

- Content Negotiation의 종류 
  - 서버 구동형 : 서버측에서 네고시에이션을 하는 방식. 리퀘스트의 헤더 필드의 정보를 참고해서 자동적으로 처리한다.
  - 에이전트 구동형 : 클라이언트측에서 네고시에이션을 하는 방식. 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택 
  - transparent : 서버 구동형과 에이전트 구동형을 혼합. 
### 15. 다음 2개의 메시지에 있는 10은 각각 몇 바이트인가? (205~206p)

```markdown
Content-Length: 10
```

```markdown
Transfer-Encoding: chunked
Content-Type: Text/plain; charset=utf-8

10
The brow fox ju
```

### 16. `WWW-Authenticate: Basic realm="Example.com` 를 클라이언트 입장에서 해석하시오. (207~208p)
### 17. URI Space를 설정하는 이유는 무엇인가? (208p)
- WWW-Authenticate 헤더를 통해 클라이언트는 서버가 제공하는 인증 방식을 이해하고 그에 따른 형식으로 인증 정보를 서버에게 보낸다. 
- Digest인증  
: 사용자 이름, 비밀번호 등을 조합하여 해시함수를 적용한 값으로 인증
- realm :   
서버상에서 해당 리소스가 속한 uri 공간의 이름 
- uri 공간 :  
 uri에서 패스 이하를 가리킴.   
클라이언트는 동일한 uri공간에 속한 리소스에는 같은 인증 정보를 송신할 수 있다고 가정되어 있어 요청을 보낼 때마다 매번 인증하는 것을 피할 수 있다. 


### 18.SSL/TLS에서 제공하는 3가지 기능에 대해서 설명하시오. (211p)

### 19.`Expires`와 `Cache-Control`의 유효기간 표시법 차이는 무엇인가? (221p)

### 20.조건부 GET `If-Modified-Since` 와 `If-None-Match` 은 어떻게 구분하여 사용하는가? (226p)

### 21. Pipelining이란 무엇인가? (227p)
 클라이언트가 지속 접속 가능한 상태에서 응답이 오기를 기다리지 않고 서버에 요청을 송신할 수 있는 것.  효율적으로 메세지를를 처리할 수 있다. 